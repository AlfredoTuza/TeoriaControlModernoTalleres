# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10ctyl593pw4jszQF5Ba5ZByWHGFpMJDD
"""

!pip install control

import numpy as np
import matplotlib.pyplot as plt
from control import ss, step_response, impulse_response
from scipy.integrate import solve_ivp

# Parámetros del circuito
R = 100         # Ohmios
L = 0.1         # Henrios
C = 1e-6        # Faradios

# Matrices del sistema
A = np.array([[0, 1],
              [-1/(L*C), -R/L]])

B = np.array([[0],
              [1/L]])

C_mat = np.array([[1/C, 0]])  # Voltaje del capacitor Vc = q/C
D = np.array([[0]])

# Sistema en espacio de estados
sys = ss(A, B, C_mat, D)

# Respuesta al escalón
t1, y_step = step_response(sys)
# Respuesta al impulso
t2, y_impulse = impulse_response(sys)

# Graficar respuestas
plt.figure(figsize=(10, 6))
plt.subplot(2,1,1)
plt.plot(t1, y_step.T)
plt.title("Respuesta al escalón")
plt.xlabel("Tiempo [s]")
plt.ylabel("Vc [V]")

plt.subplot(2,1,2)
plt.plot(t2, y_impulse.T, color='orange')
plt.title("Respuesta al impulso")
plt.xlabel("Tiempo [s]")
plt.ylabel("Vc [V]")

plt.tight_layout()
plt.show()

# -------------------------------------
# Simulación con solve_ivp (Runge-Kutta)
# -------------------------------------
def modelRLC(t, x):
    u = 1  # Entrada constante
    return A @ x + B.flatten() * u

x0 = [0, 0]
tspan = [0, 0.015]  # 15 ms
sol = solve_ivp(modelRLC, tspan, x0, t_eval=np.linspace(tspan[0], tspan[1], 1000))

# Calcular la salida Vc = C*x + D*u
y = (C_mat @ sol.y).flatten()

plt.figure()
plt.plot(sol.t, y)
plt.title("Respuesta al escalón (Runge-Kutta)")
plt.xlabel("Tiempo [s]")
plt.ylabel("Vc [V]")
plt.grid()
plt.show()

"""# Nueva sección"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.integrate import solve_ivp

# Parámetros del circuito
R = 100
L = 0.1
C = 1e-6

# Matrices del sistema
A = np.array([[0, 1], [-1/(L*C), -R/L]])
B = np.array([[0], [1/L]])
C_mat = np.array([[1/C, 0]])
D = np.array([[0]])

# ----------------------------------------
# 1. Crear y guardar señal escalón doble
# ----------------------------------------
t_total = 0.05  # 50 ms
t_eval = np.linspace(0, t_total, 2000)

# Definir valores de la señal escalón doble
u_values = []
for t in t_eval:
    if t < 0.015:
        u_values.append(0)
    elif t < 0.030:
        u_values.append(5)
    else:
        u_values.append(10)

# Guardar en CSV
df = pd.DataFrame({'tiempo': t_eval, 'entrada': u_values})
df.to_csv('escalon_doble.csv', index=False)

# ----------------------------------------
# 2. Leer señal desde CSV y simular sistema
# ----------------------------------------
data = pd.read_csv('escalon_doble.csv')
tiempos = data['tiempo'].values
entradas = data['entrada'].values
N = len(tiempos)

x0 = np.array([0, 0])
X = []
T = []

for k in range(1, N):
    tspan = [tiempos[k-1], tiempos[k]]
    u_k = entradas[k]

    def modelo(t, x):
        return A @ x + B.flatten() * u_k

    sol = solve_ivp(modelo, tspan, x0, t_eval=[tspan[1]])
    x0 = sol.y[:, -1]
    X.append(x0)
    T.append(tspan[1])

X = np.array(X)
Y = (C_mat @ X.T).flatten()

# ----------------------------------------
# 3. Graficar respuesta del sistema
# ----------------------------------------
plt.figure(figsize=(8, 5))
plt.plot(T, Y)
plt.title("Respuesta del sistema a señal escalón doble desde CSV")
plt.xlabel("Time [s]")
plt.ylabel("Vc [V]")
plt.grid(True)
plt.ylim(0, 14)
plt.show()