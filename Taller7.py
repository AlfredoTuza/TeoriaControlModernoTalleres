# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xD6v1eEMkLpIJUbwLKMRnArNGeipqs-M
"""

import numpy as np
import matplotlib.pyplot as plt
from control import tf, rlocus, tfdata
from numpy.polynomial.polynomial import Polynomial

# Definición de la función de transferencia
num = [1, 3]
den = [1, 5, 20, 16, 0]
G = tf(num, den)

# Polos y ceros
zs = np.roots(num)
ps = np.roots(den)

# Gráfica de polos y ceros
plt.figure()
plt.axis([-6, 6, -6, 6])
plt.gca().set_aspect('equal')
plt.grid(True)
plt.plot(np.real(zs), np.imag(zs), 'bo', linewidth=2, label='Ceros')
plt.plot(np.real(ps), np.imag(ps), 'rx', linewidth=2, label='Polos')
plt.title('Diagrama de Polos y Ceros')
plt.xlabel('Parte Real')
plt.ylabel('Parte Imaginaria')
plt.legend()

# Ángulos de las asíntotas
n = len(ps)
m = len(zs)
k = np.arange(0, n - m)
theta = np.pi * (2 * k + 1) / (n - m)
theta_deg = np.degrees(theta)
# Punto de origen de las asíntotas
sigma0 = (np.sum(np.real(ps)) - np.sum(np.real(zs))) / (n - m)
plt.plot(sigma0, 0, 'gh')
# Cortes con el eje imaginario
y1 = np.sqrt(3) * (0 - sigma0)
y2 = -y1
plt.plot(0, y1, 'kd')
plt.plot(0, y2, 'kd')
# Líneas de las asíntotas
x = np.arange(sigma0, 6.1, 0.1)
y1 = np.sqrt(3) * (x - sigma0)
y2 = -y1
xa = np.arange(-6, sigma0 + 0.1, 0.1)
ya = np.zeros_like(xa)
plt.plot(x, y1, 'k-.')
plt.plot(x, y2, 'k-.')
plt.plot(xa, ya, 'k-.')
# Puntos de llegada
B, A = tfdata(G)
B = np.squeeze(B)
A = np.squeeze(A)
term1 = np.convolve(B, np.polyder(A))
term2 = np.convolve(A, np.polyder(B))
max_len = max(len(term1), len(term2))
term1 = np.pad(term1, (max_len - len(term1), 0))
term2 = np.pad(term2, (max_len - len(term2), 0))
adyacentes = term1 - term2
psKs = np.roots(adyacentes)
psKs = psKs[np.imag(psKs) == 0]
plt.plot(np.real(psKs), np.imag(psKs), 'ks')

# Intersección con eje imaginario
jwint = np.roots([1, 7, -1344])
jwpol = [ (84 - jwint[1]) / 5, 0, 3 * jwint[1] ]
jwints = np.roots(jwpol)
plt.plot(np.real(jwints), np.imag(jwints), 'ks')
# Ángulo de salida
pcc = [pole for pole in ps if np.imag(pole) > 0][0]
angps = []
for pole in ps:
    if np.allclose(pole, pcc):
        continue
    delta = pcc - pole
    ang = np.degrees(np.arctan2(delta.imag, delta.real))
    if ang < 0:
        ang += 180
    angps.append(ang)

angzs = []
for zero in zs:
    delta = pcc - zero
    ang = np.degrees(np.arctan2(delta.imag, delta.real))
    if ang < 0:
        ang += 180
    angzs.append(ang)

theta_salida = 180 - sum(angps) + sum(angzs)
print("Ángulo de salida:", theta_salida)

# Lugar Geométrico de las Raíces
rlocus(G)
plt.show()